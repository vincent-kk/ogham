#!/usr/bin/env node
import { readFileSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const ROOT = join(__dirname, '..');

/**
 * Semantic version regex (https://semver.org/)
 * Matches: 0.0.1, 1.2.3, 1.0.0-beta.1, 2.0.0+build.123, etc.
 */
const SEMVER_REGEX =
  /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;

/**
 * Read and validate package.json version
 */
function readPackageVersion() {
  const packageJsonPath = join(ROOT, 'package.json');

  try {
    const content = readFileSync(packageJsonPath, 'utf-8');
    const pkg = JSON.parse(content);

    if (!pkg.version) {
      console.error('‚ùå Error: No version field found in package.json');
      process.exit(1);
    }

    if (!SEMVER_REGEX.test(pkg.version)) {
      console.error(
        `‚ùå Error: Invalid semantic version "${pkg.version}" in package.json`,
      );
      console.error(
        '   Expected format: MAJOR.MINOR.PATCH (e.g., 1.2.3, 1.0.0-beta.1)',
      );
      process.exit(1);
    }

    return pkg.version;
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.error('‚ùå Error: package.json not found at', packageJsonPath);
    } else if (error instanceof SyntaxError) {
      console.error('‚ùå Error: Invalid JSON in package.json');
    } else {
      console.error('‚ùå Error reading package.json:', error.message);
    }
    process.exit(1);
  }
}

/**
 * Generate src/version.ts with current version
 */
function generateVersionFile(version) {
  const versionFilePath = join(ROOT, 'src', 'version.ts');

  try {
    let currentVersion = null;
    try {
      const existingContent = readFileSync(versionFilePath, 'utf-8');
      const match = existingContent.match(/VERSION = ['"]([^'"]+)['"]/);
      if (match) {
        currentVersion = match[1];
      }
    } catch {
      // File doesn't exist yet, that's fine
    }

    if (currentVersion === version) {
      console.log(`‚úì src/version.ts already up to date: ${version}`);
      return false;
    }

    const content = `// Auto-generated by scripts/inject-version.mjs
// DO NOT EDIT MANUALLY - This file is generated during build

/**
 * Current package version from package.json
 * Automatically synchronized during build process
 */
export const VERSION = '${version}';
`;

    writeFileSync(versionFilePath, content, 'utf-8');

    if (currentVersion) {
      console.log(`‚úì src/version.ts updated: ${currentVersion} ‚Üí ${version}`);
    } else {
      console.log(`‚úì src/version.ts created: ${version}`);
    }
    return true;
  } catch (error) {
    console.error('‚ùå Error generating version file:', error.message);
    process.exit(1);
  }
}

/**
 * Sync version into .claude-plugin/plugin.json
 */
function syncPluginJson(version) {
  const pluginJsonPath = join(ROOT, '.claude-plugin', 'plugin.json');

  try {
    const content = readFileSync(pluginJsonPath, 'utf-8');
    const plugin = JSON.parse(content);

    if (plugin.version === version) {
      console.log(`‚úì .claude-plugin/plugin.json already up to date: ${version}`);
      return false;
    }

    const prevVersion = plugin.version;
    plugin.version = version;

    writeFileSync(pluginJsonPath, JSON.stringify(plugin, null, 2) + '\n', 'utf-8');
    console.log(`‚úì .claude-plugin/plugin.json updated: ${prevVersion} ‚Üí ${version}`);
    return true;
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.error('‚ùå Error: .claude-plugin/plugin.json not found at', pluginJsonPath);
    } else if (error instanceof SyntaxError) {
      console.error('‚ùå Error: Invalid JSON in plugin.json');
    } else {
      console.error('‚ùå Error syncing plugin.json:', error.message);
    }
    process.exit(1);
  }
}

// Main execution
try {
  const version = readPackageVersion();
  console.log(`\nüîÑ Syncing version: ${version}\n`);

  const versionUpdated = generateVersionFile(version);
  const pluginUpdated = syncPluginJson(version);

  if (!versionUpdated && !pluginUpdated) {
    console.log(`\n‚úÖ All versions already synchronized: ${version}`);
  } else {
    console.log(`\n‚úÖ Version synchronization complete: ${version}`);
  }
} catch (error) {
  console.error('‚ùå Unexpected error:', error.message);
  process.exit(1);
}
