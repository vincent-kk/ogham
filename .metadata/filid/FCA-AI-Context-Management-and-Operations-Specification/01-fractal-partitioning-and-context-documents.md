## **1\. 프랙탈 구획화 및 맥락 문서의 형태와 구조적 제약**

FCA-AI의 근본적인 철학은 전체 시스템의 코드베이스를 논리적 의미를 지니는 독립적인 단위로 구획하고, 각 단위가 스스로의 의도와 상태를 자가 설명(Self-describing)할 수 있도록 구조화하는 데 있다.1 이를 달성하기 위해 아키텍처는 시스템의 디렉토리와 모듈을 '프랙탈(Fractal)'과 '부속품(Organ)'이라는 두 가지 계층으로 엄격히 공간적으로 분리한다.1 프랙탈은 독립적인 비즈니스 로직이나 완결된 사용자 인터페이스(UI) 흐름을 가지는 도메인 경계(Bounded Context)로 정의되며, 전체 시스템을 구성하는 아키텍처의 핵심 노드 역할을 수행한다.1 반면 부속품은 프랙탈 내부에 종속되어 존재하는 컴포넌트, 유틸리티, 타입 등의 디렉토리로 프랙탈을 구동하기 위한 내부 부품에 해당한다.1

가장 중요한 아키텍처적 제약은 부속품 계층에는 독자적인 맥락 파일(CLAUDE.md)을 부여하지 않는다는 점이다.1 에이전트가 모든 유틸리티 함수나 단순 컴포넌트의 파편화된 맥락을 각각 읽어들이게 되면, 컨텍스트의 파편화와 중복이 발생하여 추론의 품질이 하락하기 때문이다.1 예외적으로 외부 의존성 없이 인터페이스만으로 기능이 완벽히 설명되는 순수 함수는 프랙탈이라 하더라도 맥락 파일을 생략하여 컨텍스트의 밀도를 극대화한다.1 이러한 공간적 구획화 위에서, 프랙탈 노드에는 에이전트의 인지를 돕는 두 가지 형태의 핵심 문서인 CLAUDE.md와 SPEC.md가 배치된다.

### **1.1. 의도와 아키텍처 히스토리의 응집체: CLAUDE.md**

CLAUDE.md 파일은 프랙탈의 진입점에 위치하며, 소스 코드의 추상 구문 트리(AST)만으로는 파악할 수 없는 개발자의 '의도'와 아키텍처 결정의 '히스토리'를 저장하는 공간이다.1 LLM은 본질적으로 상태를 갖지 않는(Stateless) 함수이므로, 에이전트가 새로운 세션을 시작할 때마다 프로젝트의 기술 스택, 디렉토리 구조, 그리고 코딩 규칙을 학습시키기 위해 이 파일이 매번 로드된다.5

효율적인 컨텍스트 관리를 위해 CLAUDE.md는 최대 100줄 이하로 유지되어야 한다는 강력한 길이 제약을 받는다.1 이 제약은 모델의 주의력 희석을 막기 위한 필수적인 안전장치이며, 상위 프랙탈의 정보를 하위 프랙탈에 중복 기입하지 않는 데이터 정규화(Deduplication) 원칙을 통해 달성된다.1 문서의 구조는 일관성을 띄어야 하며, 실행 가능한 명령어(테스트, 빌드, 린트 명령어), 프로젝트 구조, 그리고 명확한 코드 스타일 스니펫이 포함되어야 한다.6

특히 CLAUDE.md는 에이전트의 행동 반경을 제어하기 위해 3계층 경계(Three-Tier Boundaries) 시스템을 도입하여 규칙을 서술해야 한다.6 '항상 해야 할 일(Always do)'은 커밋 전 테스트 실행과 같은 필수 규범을 정의하고, '먼저 물어봐야 할 일(Ask first)'은 데이터베이스 스키마 변경이나 외부 의존성 추가와 같이 파급력이 커서 인간의 승인이 필요한 영역을 규정하며, '절대 해서는 안 될 일(Never do)'은 비밀키 커밋이나 벤더 디렉토리(node\_modules 등) 직접 수정과 같은 하드 스톱(Hard stop) 제약을 명시한다.6

형제 프랙탈 간의 수평적 참조(Horizontal Dependency)가 발생할 때 CLAUDE.md는 도메인 주도 설계(DDD)의 '공개 언어(Published Language)' 모델로 기능한다.1 프랙탈 A의 에이전트가 프랙탈 B의 기능을 참조해야 할 때, 에이전트 A는 프랙탈 B의 내부 구현 파일이나 부속품 소스 코드를 자신의 컨텍스트 윈도우로 직접 로드해서는 안 된다.1 대신 프랙탈 B가 외부에 자신의 핵심 논리와 인터페이스만을 압축하여 제공하는 CLAUDE.md 파일만을 지연 로딩(Lazy Loading) 방식으로 획득함으로써, 레거시 데이터나 이질적인 규칙이 신규 작업 공간으로 침투하는 것을 막는 에이전트 기반 충돌 방지 계층(Agentic Anti-Corruption Layer, ACL)을 형성한다.1

### **1.2. 지속적 압축과 명세 주도 개발의 원천: SPEC.md**

CLAUDE.md가 메타데이터와 의도를 제공한다면, 이와 링크로 연결되는 SPEC.md는 모듈의 상세 기능 명세를 담고 있는 문서이다.1 명세 주도 개발(Spec-Driven Development, SDD) 방법론 내에서 SPEC.md는 코드를 작성한 후 남기는 사후 문서가 아니라, 코드를 생성해 내는 '진실의 원천(Source of Truth)'이자 살아있는 실행 가능한 아티팩트(Living, executable artifact)로 취급된다.6 코드는 단지 명세를 구현한 파생물일 뿐이며, 에이전트가 코드를 탐색하다 길을 잃었을 때 기준점이 되는 닻(Anchor)의 역할을 한다.6

SPEC.md 문서는 길이 제한을 받지 않지만, 컨텍스트 부패를 막기 위해 정보가 단순히 하단에 누적(Append-only)되는 것을 엄격히 금지하며 항상 최신 상태의 로직만을 반영하도록 지속적으로 압축(Compressed)되어야 한다.1 이 압축 과정에서 시스템은 두 가지 고도화된 기법을 병행한다. 첫 번째는 '가역적 압축(Reversible Compaction)'이다. 에이전트가 500줄의 코드 파일을 작성했을 때 그 전체 내용을 명세나 대화 이력에 남기는 대신, 파일의 절대 경로와 참조 메타데이터만을 남겨 토큰을 절약하면서도 필요시 언제든 100% 원상 복구가 가능하도록 조치한다.1 두 번째는 '손실 요약(Lossy Summarization)'이다. 에이전트가 한계 토큰을 초과하여 장기 세션을 이어갈 때, 오래된 도구 호출 이력, 실패한 디버깅 로그, 중간 추적 내역 등을 구조화된 JSON 형태로 병합하여 핵심 의미만을 보존하고 노이즈를 영구적으로 제거한다.1

| 분류 항목 | CLAUDE.md (맥락 및 의도 문서) | SPEC.md (상세 명세 문서) |
| :---- | :---- | :---- |
| **핵심 목적** | 개발자 의도, 아키텍처 히스토리, 도메인 경계 규정 | 기능적 명세, API 계약, 실행 가능한 요구사항 |
| **길이 및 제약** | 최대 100줄 이하 (엄격한 밀도 통제) | 길이 제한 없음 (단, 최신화 및 구조적 압축 필수) |
| **수평적 통신** | 외부 모듈 참조 시 공개 언어(Published Language) 및 ACL 역할 수행 | 내부 모듈의 정밀 구현 및 검증을 위한 세부 지침 |
| **관리 및 최적화** | 데이터 정규화(Deduplication), 지연 로딩(Lazy Loading), 3계층 경계 | 가역적 압축(Reversible Compaction), 손실 요약(Lossy Summarization) |

#### 참고 자료

1. FCA-AI 아키텍처 심층 리서치 및 해결 방안
5. Writing a good CLAUDE.md | HumanLayer Blog, 2월 21, 2026에 액세스, [https://www.humanlayer.dev/blog/writing-a-good-claude-md](https://www.humanlayer.dev/blog/writing-a-good-claude-md)
6. How to write a good spec for AI agents \- Addy Osmani, 2월 21, 2026에 액세스, [https://addyosmani.com/blog/good-spec/](https://addyosmani.com/blog/good-spec/)
7. Creating the Perfect CLAUDE.md for Claude Code \- Dometrain, 2월 21, 2026에 액세스, [https://dometrain.com/blog/creating-the-perfect-claudemd-for-claude-code/](https://dometrain.com/blog/creating-the-perfect-claudemd-for-claude-code/)
